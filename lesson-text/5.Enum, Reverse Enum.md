###### Reverse Enum

<pre>
enum Numbers = {
    a = 10,
    b = 20,
    c = 30
}

Numbers.a       // 10
Numbers[10]     //a
</pre>

###### Числовые перечисления

<pre>
TS code: ./../lesson-files/enum/Numbers.ts
Compiled code: ./../lesson-files/enum/Numbers.js
</pre>

Взглянем на скомпилированный код, у нас создается IFFE которая, генерирует объект, 
но вместо жесткого задания ключей у нас происходит конструирование объекта с 
переликовкой на самого себя, этот механизм и позволяет нам использовать Reverse Enum
для доступа к данным enum.

###### Строковые перечисления

<pre>
TS code: ./../lesson-files/enum/Strings.ts
Compiled code: ./../lesson-files/enum/Strings.js
</pre>

Строковые перечисления (enums), очень похожи на числовые, но есть некоторые различия.
В строковом перечислении каждый член должен быть инициализирован константой строковым
литералом или другим строковым членом перечисления.

<pre>
enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT",
}
</pre>

Отличие строковых перечислений от числовых заключается в том что строковые не 
увеличиваются автоматически, но они достаточно поняты при чтении во время выполнения.

Например: При выполнении кода вы хотите проверить значение числового перечисления:

<pre>
enum PointCoordinates = {
    x: 120,
    y: 90
}

console.log(PointCoordinates.x)
</pre>

В таком случае мы получим просто число которое связано с текущим enum, это не
информативный вывод, в таком случае мы можем/должны использовать Reverse Enum, 
чтоб понять откуда берутся эти данные.

<pre>
console.log(
    PointPointCoordinates[PointCoordinates.x],
    PointPointCoordinates.x
)
</pre>

Строковые перечисления, в вою очередь, более информативны так как содержат строки,
так как мы сами придумываем их значение вне зависимости от имени ключа.

При компиляции строкового enum у нас создается IFFE которая, создает объект.
Из перечисляемых аргументов enum собирается ключ и значение 

> Compiled code: ./../lesson-files/enum/Strings.js


###### Константные перечисления

<pre>
TS code: ./../lesson-files/enum/Const.ts
Compiled code: ./../lesson-files/enum/Const.js
</pre>

Так как TypeScript компилируется в JavaScript то при создании enum и компиляции кода
в JS мы в любом случае получим IFFE которая генерирует нам нужный объект, даже если 
он не используется. Что делать если мы описали enum, но в скомпилированном коде они нам
пока не нужны, но будут нужны в будущем. Не хотелось бы нагружать свой проект данными 
которые не используются. На этот случай у нас есть константные перечисления, которые 
будет добавлять данные в скомпилированный JS только в том случае если они были описаны
и использованы дальше по коду.


###### Гетерогенные перечисления 
<pre>
TS code: ./../lesson-files/enum/Heterogeneous.ts
Compiled code: ./../lesson-files/enum/Heterogeneous.js
</pre>

Так же у нас есть возможность смешивать строковые и числовые enum, но делать это 
можно только в том случае если вы хотите добиться преимуществ при выполнении его
в браузере, а значит речь идет о JS коде. Если в рамках задачи которую вы выполняете 
вы придумали более производительный алгоритм выполнения скрипта и такой код будет
работать быстрее и лучше, тогда можно смело смешивать строковые и числовые enum. В
остальных случаях это бессмысленно.